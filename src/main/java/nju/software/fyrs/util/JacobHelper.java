package nju.software.fyrs.util;

import java.io.File;

import org.apache.log4j.Logger;

import com.jacob.activeX.ActiveXComponent;
import com.jacob.com.ComThread;
import com.jacob.com.Dispatch;
import com.jacob.com.Variant;

/**
 * 
 * jacob操作MSword类
 * 
 * @author
 */

public class JacobHelper {

	private static Logger logger = Logger.getLogger(JacobHelper.class);
	// word文档

	private Dispatch doc;

	// word运行程序对象

	private ActiveXComponent word;

	// 所有word文档集合

	private Dispatch documents;

	// 选定的范围或插入点

	private Dispatch selection;
	
	//取得活动窗体对象 
	private Dispatch activeWindow;     
  


	private boolean saveOnExit = true;

	public JacobHelper(boolean visible) throws Exception {

		ComThread.InitSTA();// 初始化com的线程，非常重要！！使用结束后要调用 realease方法

		if (word == null) {

			word = new ActiveXComponent("Word.Application");

			word.setProperty("Visible", new Variant(visible)); // 设置是否可见打开word

			word.setProperty("AutomationSecurity", new Variant(3)); // 禁用宏

		}

		if (documents == null)

			documents = word.getProperty("Documents").toDispatch();

	}

	/**
	 * 
	 * 设置退出时参数
	 * 
	 * 
	 * 
	 * @param saveOnExit
	 * 
	 *            boolean true-退出时保存文件，false-退出时不保存文件
	 */

	public void setSaveOnExit(boolean saveOnExit) {

		this.saveOnExit = saveOnExit;

	}

	/**
	 * 
	 * 创建一个新的word文档
	 * 
	 * 
	 */

	public void createNewDocument() {

		doc = Dispatch.call(documents, "Add").toDispatch();
		
		if (activeWindow == null) {
			activeWindow = word.getProperty("ActiveWindow").toDispatch(); 
		}

		selection = Dispatch.get(word, "Selection").toDispatch();

	}

	/**
	 * 
	 * 打开一个已存在的文档
	 * 
	 * 
	 * 
	 * @param docPath
	 */

	public void openDocument(String docPath) {

		closeDocument();

		doc = Dispatch.call(documents, "Open", docPath).toDispatch();

		selection = Dispatch.get(word, "Selection").toDispatch();

	}

	/**
	 * 
	 * 只读 打开一个保护文档,
	 * 
	 * @param docPath
	 *            -文件全名
	 * 
	 * @param pwd
	 *            -密码
	 */

	public void openDocumentOnlyRead(String docPath, String pwd)
			throws Exception {

		closeDocument();

		// doc = Dispatch.invoke(documents, "Open", Dispatch.Method,

		// new Object[]{docPath, new Variant(false), new Variant(true), new
		// Variant(true), pwd},

		// new int[1]).toDispatch();//打开word文件

		doc = Dispatch.callN(
				documents,
				"Open",
				new Object[] { docPath, new Variant(false),

				new Variant(true), new Variant(true), pwd, "",
						new Variant(false) }).toDispatch();

		selection = Dispatch.get(word, "Selection").toDispatch();

	}

	public void openDocument(String docPath, String pwd) throws Exception {

		closeDocument();

		doc = Dispatch.callN(documents, "Open",
				new Object[] { docPath, new Variant(false),

				new Variant(false), new Variant(true), pwd }).toDispatch();

		selection = Dispatch.get(word, "Selection").toDispatch();

	}

	/**
	 * 
	 * 把选定的内容或插入点向上移动
	 * 
	 * 
	 * 
	 * @param pos
	 * 
	 *            移动的距离
	 */

	public void moveUp(int pos) {

		if (selection == null)

			selection = Dispatch.get(word, "Selection").toDispatch();

		for (int i = 0; i < pos; i++)

			Dispatch.call(selection, "MoveUp");

	}

	/**
	 * 
	 * 把选定的内容或者插入点向下移动
	 * 
	 * 
	 * 
	 * @param pos
	 * 
	 *            移动的距离
	 */

	public void moveDown(int pos) {

		if (selection == null)

			selection = Dispatch.get(word, "Selection").toDispatch();

		for (int i = 0; i < pos; i++)

			Dispatch.call(selection, "MoveDown");

	}

	/**
	 * 
	 * 把选定的内容或者插入点向左移动
	 * 
	 * 
	 * 
	 * @param pos
	 * 
	 *            移动的距离
	 */

	public void moveLeft(int pos) {

		if (selection == null)

			selection = Dispatch.get(word, "Selection").toDispatch();

		for (int i = 0; i < pos; i++) {

			Dispatch.call(selection, "MoveLeft");

		}

	}

	/**
	 * 
	 * 把选定的内容或者插入点向右移动
	 * 
	 * 
	 * 
	 * @param pos
	 * 
	 *            移动的距离
	 */

	public void moveRight(int pos) {

		if (selection == null)

			selection = Dispatch.get(word, "Selection").toDispatch();

		for (int i = 0; i < pos; i++)

			Dispatch.call(selection, "MoveRight");

	}

	/**
	 * 
	 * 把插入点移动到文件首位置
	 * 
	 * 
	 */

	public void moveStart() {

		if (selection == null)

			selection = Dispatch.get(word, "Selection").toDispatch();

		Dispatch.call(selection, "HomeKey", new Variant(6));

	}

	/**
	 * 
	 * 从选定内容或插入点开始查找文本
	 * 
	 * 
	 * 
	 * @param toFindText
	 * 
	 *            要查找的文本
	 * 
	 * @return boolean true-查找到并选中该文本，false-未查找到文本
	 */

	@SuppressWarnings("static-access")
	public boolean find(String toFindText) {

		if (toFindText == null || toFindText.equals(""))

			return false;

		// 从selection所在位置开始查询

		Dispatch find = word.call(selection, "Find").toDispatch();

		// 设置要查找的内容

		Dispatch.put(find, "Text", toFindText);

		// 向前查找

		Dispatch.put(find, "Forward", "True");

		// 设置格式

		Dispatch.put(find, "Format", "True");

		// 大小写匹配

		Dispatch.put(find, "MatchCase", "True");

		// 全字匹配

		Dispatch.put(find, "MatchWholeWord", "True");

		// 查找并选中

		return Dispatch.call(find, "Execute").getBoolean();

	}

	/**
	 * 
	 * 把选定选定内容设定为替换文本
	 * 
	 * 
	 * 
	 * @param toFindText
	 * 
	 *            查找字符串
	 * 
	 * @param newText
	 * 
	 *            要替换的内容
	 * 
	 * @return
	 */

	public boolean replaceText(String toFindText, String newText) {

		if (!find(toFindText))

			return false;

		Dispatch.put(selection, "Text", newText);

		return true;

	}

	/**
	 * 
	 * 全局替换文本
	 * 
	 * 
	 * 
	 * @param toFindText
	 * 
	 *            查找字符串
	 * 
	 * @param newText
	 * 
	 *            要替换的内容
	 */

	public void replaceAllText(String toFindText, String newText) {

		while (find(toFindText)) {

			Dispatch.put(selection, "Text", newText);

			Dispatch.call(selection, "MoveRight");

		}

	}

	/**
	 * 
	 * 在当前插入点插入字符串
	 * 
	 * 
	 * 
	 * @param newText
	 * 
	 *            要插入的新字符串
	 */

	public void insertText(String newText, boolean bold, boolean italic, boolean underLine,

			String colorSize, String size, String name) {

		if (StringUtil.isEmpty(newText)) {
			return;
		}
		//Dispatch.put(selection, "Text", newText);
		Dispatch.call(selection, "InsertAfter", newText);
		setFont(bold, italic, underLine, colorSize, size, name);
		moveLeft(1);
		moveRight(newText.length());

	}
	
	/**
	 * 新增方法，将insertText方法中moveRight去掉
	 * @param newText
	 * @param bold
	 * @param italic
	 * @param underLine
	 * @param colorSize
	 * @param size
	 * @param name
	 */
	public void insertTextNoMoveRight(String newText, boolean bold, boolean italic, boolean underLine,

			String colorSize, String size, String name) {

		//Dispatch.put(selection, "Text", newText);
		Dispatch.call(selection, "InsertAfter", newText);
		setFont(bold, italic, underLine, colorSize, size, name);
		//moveRight(newText.length());

	}
	
	public void enterDown(int count){          
		for(int i = 0;i < count;i++) {      
			Dispatch.call(this.selection, "TypeParagraph");      
		}      
	} 
	


	/**
	 * 
	 * 
	 * 
	 * @param toFindText
	 * 
	 *            要查找的字符串
	 * 
	 * @param imagePath
	 * 
	 *            图片路径
	 * 
	 * @return
	 */

	public boolean replaceImage(String toFindText, String imagePath) {

		if (!find(toFindText))

			return false;

		Dispatch.call(Dispatch.get(selection, "InLineShapes").toDispatch(),

		"AddPicture", imagePath);

		return true;

	}

	/**
	 * 
	 * 全局替换图片
	 * 
	 * 
	 * 
	 * @param toFindText
	 * 
	 *            查找字符串
	 * 
	 * @param imagePath
	 * 
	 *            图片路径
	 */

	public void replaceAllImage(String toFindText, String imagePath) {

		while (find(toFindText)) {

			Dispatch.call(Dispatch.get(selection, "InLineShapes").toDispatch(),

			"AddPicture", imagePath);

			Dispatch.call(selection, "MoveRight");

		}

	}

	/**
	 * 
	 * 在当前插入点插入图片
	 * 
	 * 
	 * 
	 * @param imagePath
	 * 
	 *            图片路径
	 */

	public void insertImage(String imagePath) {

		Dispatch.call(Dispatch.get(selection, "InLineShapes").toDispatch(),

		"AddPicture", imagePath);

	}
	
	public boolean insertImage(byte imageByte[], String imageSavePath) {
		
		File image = new File(imageSavePath);

		if (image.exists()) {
			/*try {
				FileOutputStream out = new FileOutputStream(image);
				out.write(imageByte, 0, imageByte.length);
				out.close();
			} catch (Exception e) {
				
				logger.error("插入图片失败：" + imageSavePath,e);
			}*/
			Dispatch.call(Dispatch.get(selection, "InLineShapes").toDispatch(), "AddPicture", imageSavePath);
			return true;
		}else {
			return false;
		}
		
		
	}

	/**
	 * 
	 * 合并单元格
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param fstCellRowIdx
	 * 
	 * @param fstCellColIdx
	 * 
	 * @param secCellRowIdx
	 * 
	 * @param secCellColIdx
	 */

	public void mergeCell(int tableIndex, int fstCellRowIdx, int fstCellColIdx,

	int secCellRowIdx, int secCellColIdx) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch fstCell = Dispatch.call(table, "Cell",

		new Variant(fstCellRowIdx), new Variant(fstCellColIdx))

		.toDispatch();

		Dispatch secCell = Dispatch.call(table, "Cell",

		new Variant(secCellRowIdx), new Variant(secCellColIdx))

		.toDispatch();

		Dispatch.call(fstCell, "Merge", secCell);

	}

	/**
	 * 
	 * 在指定的单元格里填写数据
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param cellRowIdx
	 * 
	 * @param cellColIdx
	 * 
	 * @param txt
	 */

	public void putTxtToCell(int tableIndex, int cellRowIdx, int cellColIdx,

	String txt) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch cell = Dispatch.call(table, "Cell", new Variant(cellRowIdx),

		new Variant(cellColIdx)).toDispatch();

		Dispatch.call(cell, "Select");

		Dispatch.put(selection, "Text", txt);

	}

	/**
	 * 
	 * 获得指定的单元格里数据
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param cellRowIdx
	 * 
	 * @param cellColIdx
	 * 
	 * @return
	 */

	public String getTxtFromCell(int tableIndex, int cellRowIdx, int cellColIdx) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch cell = Dispatch.call(table, "Cell", new Variant(cellRowIdx),

		new Variant(cellColIdx)).toDispatch();

		Dispatch.call(cell, "Select");

		String ret = "";

		ret = Dispatch.get(selection, "Text").toString();

		ret = ret.substring(0, ret.length() - 1); // 去掉最后的回车符;

		return ret;

	}

	/**
	 * 
	 * 在当前文档拷贝剪贴板数据
	 * 
	 * @param pos
	 */

	public void pasteExcelSheet(String pos) {

		moveStart();

		if (this.find(pos)) {

			Dispatch textRange = Dispatch.get(selection, "Range").toDispatch();

			Dispatch.call(textRange, "Paste");

		}

	}

	/**
	 * 
	 * 在当前文档指定的位置拷贝表格
	 * 
	 * 
	 * 
	 * @param pos
	 * 
	 *            当前文档指定的位置
	 * 
	 * @param tableIndex
	 * 
	 *            被拷贝的表格在word文档中所处的位置
	 */

	public void copyTable(String pos, int tableIndex) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch range = Dispatch.get(table, "Range").toDispatch();

		Dispatch.call(range, "Copy");

		if (this.find(pos)) {

			Dispatch textRange = Dispatch.get(selection, "Range").toDispatch();

			Dispatch.call(textRange, "Paste");

		}

	}

	/**
	 * 
	 * 在当前文档指定的位置拷贝来自另一个文档中的表格
	 * 
	 * 
	 * 
	 * @param anotherDocPath
	 * 
	 *            另一个文档的磁盘路径
	 * 
	 * @param tableIndex
	 * 
	 *            被拷贝的表格在另一格文档中的位置
	 * 
	 * @param pos
	 * 
	 *            当前文档指定的位置
	 */

	public void copyTableFromAnotherDoc(String anotherDocPath, int tableIndex,

	String pos) {

		Dispatch doc2 = null;

		try {

			doc2 = Dispatch.call(documents, "Open", anotherDocPath)

			.toDispatch();

			// 所有表格

			Dispatch tables = Dispatch.get(doc2, "Tables").toDispatch();

			// 要填充的表格

			Dispatch table = Dispatch.call(tables, "Item",

			new Variant(tableIndex)).toDispatch();

			Dispatch range = Dispatch.get(table, "Range").toDispatch();

			Dispatch.call(range, "Copy");

			if (this.find(pos)) {

				Dispatch textRange = Dispatch.get(selection, "Range")

				.toDispatch();

				Dispatch.call(textRange, "Paste");

			}

		} catch (Exception e) {

			
			logger.error("", e);
		} finally {

			if (doc2 != null) {

				Dispatch.call(doc2, "Close", new Variant(saveOnExit));

				doc2 = null;

			}

		}

	}

	/**
	 * 
	 * 在当前文档指定的位置拷贝来自另一个文档中的图片
	 * 
	 * 
	 * 
	 * @param anotherDocPath
	 *            另一个文档的磁盘路径
	 * 
	 * @param shapeIndex
	 *            被拷贝的图片在另一格文档中的位置
	 * 
	 * @param pos
	 *            当前文档指定的位置
	 */

	public void copyImageFromAnotherDoc(String anotherDocPath, int shapeIndex,

	String pos) {

		Dispatch doc2 = null;

		try {

			doc2 = Dispatch.call(documents, "Open", anotherDocPath)

			.toDispatch();

			Dispatch shapes = Dispatch.get(doc2, "InLineShapes").toDispatch();

			Dispatch shape = Dispatch.call(shapes, "Item",

			new Variant(shapeIndex)).toDispatch();

			Dispatch imageRange = Dispatch.get(shape, "Range").toDispatch();

			Dispatch.call(imageRange, "Copy");

			if (this.find(pos)) {

				Dispatch textRange = Dispatch.get(selection, "Range")

				.toDispatch();

				Dispatch.call(textRange, "Paste");

			}

		} catch (Exception e) {

			logger.error("", e);

		} finally {

			if (doc2 != null) {

				Dispatch.call(doc2, "Close", new Variant(saveOnExit));

				doc2 = null;

			}

		}

	}

	/**
	 * 
	 * 创建表格
	 * 
	 * 
	 * 
	 * @param pos
	 * 
	 *            位置
	 * 
	 * @param cols
	 * 
	 *            列数
	 * 
	 * @param rows
	 * 
	 *            行数
	 */

	public void createTable(String pos, int numCols, int numRows) {

		if (find(pos)) {

			Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

			Dispatch range = Dispatch.get(selection, "Range").toDispatch();

			@SuppressWarnings("unused")
			Dispatch newTable = Dispatch.call(tables, "Add", range,

			new Variant(numRows), new Variant(numCols)).toDispatch();

			Dispatch.call(selection, "MoveRight");

		} else {

			Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

			Dispatch range = Dispatch.get(selection, "Range").toDispatch();

			@SuppressWarnings("unused")
			Dispatch newTable = Dispatch.call(tables, "Add", range,

			new Variant(numRows), new Variant(numCols)).toDispatch();

			Dispatch.call(selection, "MoveRight");

		}

	}

	/**
	 * 
	 * 在指定行前面增加行
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文件中的第N张表(从1开始)
	 * 
	 * @param rowIndex
	 * 
	 *            指定行的序号(从1开始)
	 */

	public void addTableRow(int tableIndex, int rowIndex) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch rows = Dispatch.get(table, "Rows").toDispatch();

		Dispatch row = Dispatch.call(rows, "Item", new Variant(rowIndex))

		.toDispatch();

		Dispatch.call(rows, "Add", new Variant(row));

	}

	/**
	 * 
	 * 在第1行前增加一行
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 */

	public void addFirstTableRow(int tableIndex) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch rows = Dispatch.get(table, "Rows").toDispatch();

		Dispatch row = Dispatch.get(rows, "First").toDispatch();

		Dispatch.call(rows, "Add", new Variant(row));

	}

	/**
	 * 
	 * 在最后1行前增加一行
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 */

	public void addLastTableRow(int tableIndex) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch rows = Dispatch.get(table, "Rows").toDispatch();

		Dispatch row = Dispatch.get(rows, "Last").toDispatch();

		Dispatch.call(rows, "Add", new Variant(row));

	}

	/**
	 * 
	 * 增加一行
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 */

	public void addRow(int tableIndex) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch rows = Dispatch.get(table, "Rows").toDispatch();

		Dispatch.call(rows, "Add");

	}

	/**
	 * 
	 * 增加一列
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 */

	public void addCol(int tableIndex) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch cols = Dispatch.get(table, "Columns").toDispatch();

		Dispatch.call(cols, "Add").toDispatch();

		Dispatch.call(cols, "AutoFit");

	}

	/**
	 * 
	 * 在指定列前面增加表格的列
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 * 
	 * @param colIndex
	 * 
	 *            制定列的序号 (从1开始)
	 */

	public void addTableCol(int tableIndex, int colIndex) {

		// 所有表格

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch cols = Dispatch.get(table, "Columns").toDispatch();

		System.out.println(Dispatch.get(cols, "Count"));

		Dispatch col = Dispatch.call(cols, "Item", new Variant(colIndex))

		.toDispatch();

		// Dispatch col = Dispatch.get(cols, "First").toDispatch();

		Dispatch.call(cols, "Add", col).toDispatch();

		Dispatch.call(cols, "AutoFit");

	}

	/**
	 * 
	 * 在第1列前增加一列
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 */

	public void addFirstTableCol(int tableIndex) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch cols = Dispatch.get(table, "Columns").toDispatch();

		Dispatch col = Dispatch.get(cols, "First").toDispatch();

		Dispatch.call(cols, "Add", col).toDispatch();

		Dispatch.call(cols, "AutoFit");

	}

	/**
	 * 
	 * 在最后一列前增加一列
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 *            word文档中的第N张表(从1开始)
	 */

	public void addLastTableCol(int tableIndex) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		// 要填充的表格

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		// 表格的所有行

		Dispatch cols = Dispatch.get(table, "Columns").toDispatch();

		Dispatch col = Dispatch.get(cols, "Last").toDispatch();

		Dispatch.call(cols, "Add", col).toDispatch();

		Dispatch.call(cols, "AutoFit");

	}

	/**
	 * 
	 * 自动调整表格
	 * 
	 * 
	 */

	@SuppressWarnings("deprecation")
	public void autoFitTable() {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		int count = Dispatch.get(tables, "Count").toInt();

		for (int i = 0; i < count; i++) {

			Dispatch table = Dispatch.call(tables, "Item", new Variant(i + 1))

			.toDispatch();

			Dispatch cols = Dispatch.get(table, "Columns").toDispatch();

			Dispatch.call(cols, "AutoFit");

		}

	}

	/**
	 * 
	 * 调用word里的宏以调整表格的宽度,其中宏保存在document下
	 * 
	 * 
	 */

	@SuppressWarnings("deprecation")
	public void callWordMacro() {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		int count = Dispatch.get(tables, "Count").toInt();

		Variant vMacroName = new Variant("Normal.NewMacros.tableFit");

		@SuppressWarnings("unused")
		Variant vParam = new Variant("param1");

		@SuppressWarnings("unused")
		Variant para[] = new Variant[] { vMacroName };

		for (int i = 0; i < count; i++) {

			Dispatch table = Dispatch.call(tables, "Item", new Variant(i + 1))

			.toDispatch();

			Dispatch.call(table, "Select");

			Dispatch.call(word, "Run", "tableFitContent");

		}

	}
	
	/**
	 * 设置选中东西的水平对其方式
	 * @param Align
	 */
	public void setCellAlignment(int Align) {
		Dispatch paragraphs = Dispatch.get(selection, "Paragraphs").toDispatch();
		Dispatch.put(paragraphs, "Alignment", new Variant(Align));
	}
	
	public void setPageSetup(int paperSize) {
		Dispatch pagesetup = Dispatch.get(selection, "PageSetup").toDispatch();
		Dispatch.put(pagesetup, "PaperSize", new Variant(paperSize));
	}

	/**
	 * 设置页面格式
	 * @param paperSize
	 * @param topMargin
	 * @param rightMargin
	 * @param bottomMargin
	 * @param leftMargin
	 * @param pageNumber
	 */
	public void setPage(int paperSize, double topMargin, double rightMargin,
			double bottomMargin, double leftMargin, boolean pageNumber) {
		Dispatch pagesetup = Dispatch.get(selection, "PageSetup").toDispatch();
		Dispatch.put(pagesetup, "TopMargin", new Variant(topMargin));
		Dispatch.put(pagesetup, "RightMargin", new Variant(rightMargin));
		Dispatch.put(pagesetup, "BottomMargin", new Variant(bottomMargin));
		Dispatch.put(pagesetup, "LeftMargin", new Variant(leftMargin));
		Dispatch.put(pagesetup, "PaperSize", new Variant(paperSize));
		
		if (pageNumber) {
			//取得活动窗格对象   
			Dispatch ActivePane = Dispatch.get(activeWindow, "ActivePane").toDispatch();   
			//取得视窗对象   
			Dispatch View = Dispatch.get(ActivePane, "View").toDispatch();
			Dispatch.put(View, "SeekView", new Variant(10));
			
			Dispatch footer = Dispatch.get(selection, "HeaderFooter").toDispatch(); 
			Dispatch pageNumbers = Dispatch.get(footer, "PageNumbers").toDispatch();
			Dispatch.call(pageNumbers, "Add", new Variant(1));

			Dispatch.put(View, "SeekView", new Variant(9));
			Dispatch.call(selection, "WholeStory");
			Dispatch borders = Dispatch.get(selection, "Borders").toDispatch();
			Dispatch.put(borders, "OutsideLineStyle", new Variant(0));
			
			Dispatch.put(View, "SeekView", new Variant(0));  
		}
		
	}

	/**
	 * 
	 * 设置当前选定内容的字体
	 * 
	 * 
	 * 
	 * @param boldSize
	 * 
	 * @param italicSize
	 * 
	 * @param underLineSize
	 * 
	 *            下划线
	 * 
	 * @param colorSize
	 * 
	 *            字体颜色
	 * 
	 * @param size
	 * 
	 *            字体大小
	 * 
	 * @param name
	 * 
	 *            字体名称
	 */

	public void setFont(boolean bold, boolean italic, boolean underLine,

	String colorSize, String size, String name) {

		Dispatch font = Dispatch.get(selection, "Font").toDispatch();

		Dispatch.put(font, "Name", new Variant(name));

		Dispatch.put(font, "Bold", new Variant(bold));

		Dispatch.put(font, "Italic", new Variant(italic));

		Dispatch.put(font, "Underline", new Variant(underLine));

		Dispatch.put(font, "Color", colorSize);

		Dispatch.put(font, "Size", size);

	}

	/**
	 * 
	 * 设置单元格被选中
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param cellRowIdx
	 * 
	 * @param cellColIdx
	 */

	public void setTableCellSelected(int tableIndex, int cellRowIdx,
			int cellColIdx) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch cell = Dispatch.call(table, "Cell", new Variant(cellRowIdx),

		new Variant(cellColIdx)).toDispatch();

		Dispatch.call(cell, "Select");

	}
	
	/**
	 * 
	 * 设置行被选中
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param cellRowIdx
	 * 
	 * @param cellColIdx
	 */

	public void setTableRowSelected(int tableIndex, int cellRowIdx) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch row = Dispatch.call(table, "Rows", new Variant(cellRowIdx)).toDispatch();

		Dispatch.call(row, "Select");

	}
	
	/**
	 * 
	 * 设置列被选中
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param cellRowIdx
	 * 
	 * @param cellColIdx
	 */

	public void setTableColSelected(int tableIndex, int cellColIdx) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch column = Dispatch.call(table, "Columns", new Variant(cellColIdx)).toDispatch();

		Dispatch.call(column, "Select");

	}
	
	/**
	 * 
	 * 设置整个表格被选中
	 * 
	 * 
	 * 
	 * @param tableIndex
	 * 
	 * @param cellRowIdx
	 * 
	 * @param cellColIdx
	 */

	public void setTableSelected(int tableIndex) {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))

		.toDispatch();

		Dispatch.call(table, "Select");

	}
	
	

	/**
	 * 
	 * 设置选定单元格的垂直对起方式, 请使用setTableCellSelected选中一个单元格
	 * 
	 * @param align
	 *            0-顶端, 1-居中, 3-底端
	 */

	public void setCellVerticalAlign(int verticalAlign) {

		Dispatch cells = Dispatch.get(selection, "Cells").toDispatch();

		Dispatch.put(cells, "VerticalAlignment", new Variant(verticalAlign));

	}
	
	/**
	 * 设置选中单元格的宽度
	 * @param width
	 */
	public void setCellSetWidth(Integer ruleStyle, double columnWidth) {
		Dispatch cells = Dispatch.get(selection, "Cells").toDispatch();
		Dispatch.call(cells, "RulerStyle", new Variant(ruleStyle));
		Dispatch.call(cells, "ColumnWidth", new Variant(columnWidth));
	}
	
	/**
	 * 设置选中单元格的宽度
	 * @param width
	 */
	public void setCellWidth(Integer preferredWidthType, double preferredWidth) {
		Dispatch cells = Dispatch.get(selection, "Cells").toDispatch();
		Dispatch.put(cells, "PreferredWidthType", new Variant(preferredWidthType));
		Dispatch.put(cells, "PreferredWidth", new Variant(preferredWidth));
	}
	
	
	/**
	 * 设置表格边框
	 * @param tableIndex
	 * @param insideLineStyle
	 * @param outsideLineStyle
	 */
	public void setTableBorders(int tableIndex, int insideLineStyle, int outsideLineStyle) {
		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();
		Dispatch table = Dispatch.call(tables, "Item", new Variant(tableIndex))
				.toDispatch();
		Dispatch borders = Dispatch.get(table, "Borders").toDispatch();
		Dispatch.put(borders, "InsideLineStyle", new Variant(insideLineStyle));
		Dispatch.put(borders, "OutsideLineStyle", new Variant(outsideLineStyle));
	}

	/**
	 * 
	 * 设置当前文档中所有表格水平居中方式及其它一些格式,用在将word文件转化为html中,针对申报表
	 */

	public void setApplyTableFormat() {

		Dispatch tables = Dispatch.get(doc, "Tables").toDispatch();

		int tabCount = Integer.valueOf(Dispatch.get(tables, "Count").toString()); 

		for (int i = 1; i <= tabCount; i++) {

			Dispatch table = Dispatch.call(tables, "Item", new Variant(i))
					.toDispatch();

			Dispatch rows = Dispatch.get(table, "Rows").toDispatch();

			Dispatch.put(rows, "Alignment", new Variant(1)); // 1-居中

			Dispatch.call(table, "AutoFitBehavior", new Variant(0));

			Dispatch.put(table, "PreferredWidthType", new Variant(2));

			Dispatch.put(table, "PreferredWidth", new Variant(100));

			//System.out.println(Dispatch.get(rows, "HeightRule").toString());

			Dispatch.put(rows, "HeightRule", new Variant(0)); // 0-自动wdRowHeightAuto,1-最小值wdRowHeightAtLeast,
																// 2-固定wdRowHeightExactly

			//Dispatch.put(rows, "Height", new Variant(0.04 * 28.35));
		}

	}

	/**
	 * 
	 * 设置段落格式
	 * 
	 * 
	 * 
	 * @param alignment
	 * 
	 *            0-左对齐, 1-右对齐, 2-右对齐, 3-两端对齐, 4-分散对齐
	 * 
	 * @param lineSpacingRule
	 * 
	 * @param lineUnitBefore
	 * 
	 * @param lineUnitAfter
	 * 
	 * @param characterUnitFirstLineIndent
	 */

	public void setParagraphsProperties(int alignment, int lineSpacingRule,
			double lineSpacing, int lineUnitBefore, int lineUnitAfter,
			int characterUnitFirstLineIndent) {

		Dispatch paragraphs = Dispatch.get(selection, "Paragraphs")
				.toDispatch();

		Dispatch.put(paragraphs, "Alignment", new Variant(alignment)); // 对齐方式

		Dispatch.put(paragraphs, "LineSpacingRule",
				new Variant(lineSpacingRule)); // 行距

		if (lineSpacingRule > 2) {
			Dispatch.put(paragraphs, "LineSpacing", new Variant(lineSpacing));
		}

		Dispatch.put(paragraphs, "LineUnitBefore", new Variant(lineUnitBefore)); // 段前

		Dispatch.put(paragraphs, "LineUnitAfter", new Variant(lineUnitAfter)); // 段后

		Dispatch.put(paragraphs, "CharacterUnitFirstLineIndent",

		new Variant(characterUnitFirstLineIndent)); // 首行缩进字符数

	}

	/**
	 * 
	 * 打印当前段落格式, 使用前,请先选中段落
	 */

	public void getParagraphsProperties() {

		Dispatch paragraphs = Dispatch.get(selection, "Paragraphs")
				.toDispatch();

		String val = Dispatch.get(paragraphs, "LineSpacingRule").toString(); // 行距

		System.out.println("行距:" + val);

		val = Dispatch.get(paragraphs, "Alignment").toString(); // 对齐方式

		System.out.println("对齐方式:" + val); // 0-左对齐, 1-右对齐, 2-右对齐, 3-两端对齐,
											// 4-分散对齐

		val = Dispatch.get(paragraphs, "LineUnitBefore").toString(); // 段前行数

		System.out.println("段前行数:" + val);

		val = Dispatch.get(paragraphs, "LineUnitAfter").toString(); // 段后行数

		System.out.println("段后行数:" + val);

		val = Dispatch.get(paragraphs, "FirstLineIndent").toString(); // 首行缩进

		System.out.println("首行缩进:" + val);

		val = Dispatch.get(paragraphs, "CharacterUnitFirstLineIndent")
				.toString(); // 首行缩进字符数

		System.out.println("首行缩进字符数:" + val);

	}

	/**
	 * 
	 * 文件保存或另存为
	 * 
	 * 
	 * 
	 * @param savePath
	 * 
	 *            保存或另存为路径
	 */

	public void save(String savePath) {

		/*Dispatch.call(Dispatch.call(word, "WordBasic").getDispatch(),

		"SaveAs", savePath);*/
		Dispatch.invoke(doc, "SaveAs", Dispatch.Method,

				new Object[] { savePath, new Variant(0) }, new int[1]);

	}

	/**
	 * 
	 * 文件保存为html格式
	 * 
	 * 
	 * 
	 * @param savePath
	 * 
	 * @param htmlPath
	 */

	public void saveAsHtml(String htmlPath) {

		Dispatch.invoke(doc, "SaveAs", Dispatch.Method,

		new Object[] { htmlPath, new Variant(8) }, new int[1]);

	}

	/**
	 * 
	 * 关闭文档
	 * 
	 * @param val
	 *            0不保存修改 -1 保存修改 -2 提示是否保存修改
	 */

	public void closeDocument(int val) {

		Dispatch.call(doc, "Close", new Variant(val));

		doc = null;

	}

	/**
	 * 
	 * 关闭当前word文档
	 * 
	 * 
	 */

	public void closeDocument() {

		if (doc != null) {

			Dispatch.call(doc, "Save");

			Dispatch.call(doc, "Close", new Variant(saveOnExit));

			doc = null;

		}

	}

	public void closeDocumentWithoutSave() {

		if (doc != null) {

			Dispatch.call(doc, "Close", new Variant(false));

			doc = null;

		}

	}

	/**
	 * 
	 * 关闭全部应用
	 * 
	 * 
	 */

	public void close() {

		// closeDocument();
		if (word != null) {
			/*Dispatch template = word.getProperty("NormalTemplate").toDispatch();
			//判断是否保存模板
			boolean  saved = Dispatch.get(template,"Saved").getBoolean();
			if(!saved){
				//保存模板
				Dispatch.put(template, "Saved", true);
			}*/

			Dispatch.call(word, "Quit", new Variant(0));

			word = null;

		}

		selection = null;

		documents = null;

		ComThread.Release();// 释放com线程。根据jacob的帮助文档，com的线程回收不由java的垃圾回收器处理

	}

	/**
	 * 
	 * 打印当前word文档
	 * 
	 * 
	 */

	public void printFile() {

		if (doc != null) {

			Dispatch.call(doc, "PrintOut");

		}

	}

	/**
	 * 
	 * 保护当前档,如果不存在, 使用expression.Protect(Type, NoReset, Password)
	 * 
	 * 
	 * 
	 * @param pwd
	 * 
	 *            WdProtectionType 可以是下列 WdProtectionType 常量之一：
	 * 
	 *            1-wdAllowOnlyComments, 2-wdAllowOnlyFormFields,
	 *            0-wdAllowOnlyRevisions,
	 * 
	 *            -1-wdNoProtection, 3-wdAllowOnlyReading
	 * 
	 * 
	 */

	public void protectedWord(String pwd) {

		String protectionType = Dispatch.get(doc, "ProtectionType").toString();

		if (protectionType.equals("-1")) {

			Dispatch.call(doc, "Protect", new Variant(3), new Variant(true),
					pwd);

		}

	}

	/**
	 * 
	 * 解除文档保护,如果存在
	 * 
	 * @param pwd
	 * 
	 *            WdProtectionType 常量之一(Long 类型，只读)：
	 * 
	 *            1-wdAllowOnlyComments,2-wdAllowOnlyFormFields、
	 * 
	 *            0-wdAllowOnlyRevisions,-1-wdNoProtection, 3-wdAllowOnlyReading
	 * 
	 * 
	 */

	public void unProtectedWord(String pwd) {

		String protectionType = Dispatch.get(doc, "ProtectionType").toString();

		if (protectionType.equals("3")) {

			Dispatch.call(doc, "Unprotect", pwd);

		}

	}

	/**
	 * 
	 * 设置word文档安全级别
	 * 
	 * @param value
	 * 
	 *            1-msoAutomationSecurityByUI 使用“安全”对话框指定的安全设置。
	 * 
	 *            2-msoAutomationSecurityForceDisable
	 *            在程序打开的所有文件中禁用所有宏，而不显示任何安全提醒。
	 * 
	 *            3-msoAutomationSecurityLow 启用所有宏，这是启动应用程序时的默认值。
	 */

	public void setAutomationSecurity(int value) {

		word.setProperty("AutomationSecurity", new Variant(value));

	}

	/**
	 * 
	 * 读取文档中第paragraphsIndex段文字的内容;
	 * 
	 * @param paragraphsIndex
	 * 
	 * @return
	 */

	public String getParagraphs(int paragraphsIndex) {

		String ret = "";

		Dispatch paragraphs = Dispatch.get(doc, "Paragraphs").toDispatch(); // 所有段落

		int paragraphCount = Dispatch.get(paragraphs, "Count").getInt(); // 一共的段落数

		Dispatch paragraph = null;

		Dispatch range = null;

		if (paragraphCount > paragraphsIndex && 0 < paragraphsIndex) {

			paragraph = Dispatch.call(paragraphs, "Item",
					new Variant(paragraphsIndex)).toDispatch();

			range = Dispatch.get(paragraph, "Range").toDispatch();

			ret = Dispatch.get(range, "Text").toString();

		}

		return ret;

	}

	/*
	 * public static void main(String[] args) throws Exception {
	 * 
	 * WordBean word = new WordBean();
	 * 
	 * word.createNewDocument();
	 * 
	 * word.createTable("", 5, 5);
	 * 
	 * word.mergeCell(1, 1, 1, 1, 5);
	 * 
	 * word.mergeCell(1, 2, 1, 2, 5);
	 * 
	 * word.mergeCell(1, 3, 1, 3, 5);
	 * 
	 * word.putTxtToCell(1, 1, 1, "主题");
	 * 
	 * word.putTxtToCell(1, 2, 1, "时间");
	 * 
	 * word.putTxtToCell(1, 3, 1, "人员");
	 * 
	 * word.putTxtToCell(1, 4, 2, "说话了");
	 * 
	 * word.save("c:\\jacobTest.doc");
	 * 
	 * System.out.print("请打开c:\\jacobTest.doc查看是否有写word成功!");
	 * 
	 * word.close();
	 * 
	 * }
	 */

}